package metric

import (
	"math"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

// growing time for tests to avoid errors generated by store avoiding samples too close in time
var (
	now = time.Now()
	_   = func() time.Time {
		now = now.Add(1 * time.Second)
		return now
	}
)

var _ = []struct {
	testCase string
	key      string
	value    interface{}
	out      interface{}
	cache    interface{}
}{
	{"1st data in key", "key1", .22323333, 0.0, 0.22323333},
	{"1st data in key", "key2", 100, 0.0, 100.0},
	{"2nd data in key", "key2", 110, 10.0, 110.0},
}

func Test_Metric_CreateGauge(t *testing.T) {
	g, _ := NewGauge(now, "gauge", 1)
	assert.NotNil(t, g)
}

func Test_Metric_CannotCreateGaugeWithEmptyName(t *testing.T) {
	g, err := NewGauge(now, "", 1)
	assert.Nil(t, g)
	assert.Error(t, err)
}

func Test_Metric_CreateCount(t *testing.T) {
	c, _ := NewCount(now, "count", 1)
	assert.NotNil(t, c)
}

func Test_Metric_CannotCreateCountWithEmptyName(t *testing.T) {
	c, err := NewCount(now, "", 1)
	assert.Nil(t, c)
	assert.Error(t, err)
}

func Test_Metric_CannotCreateCountWithNegativeValue(t *testing.T) {
	c, err := NewCount(now, "count", -1)
	assert.Nil(t, c)
	assert.Error(t, err)

	c, err = NewCount(now, "count", -1.0)
	assert.Nil(t, c)
	assert.Error(t, err)

	c, err = NewCount(now, "count", 0)
	assert.NotNil(t, c)
	assert.NoError(t, err)
}

func Test_Metric_CreateSummary(t *testing.T) {
	s, _ := NewSummary(now, "summary", 1, 0.5, 1, 0, 1)
	assert.NotNil(t, s)
}

func Test_Metric_CannotCreateSummaryWithEmptyName(t *testing.T) {
	s, err := NewSummary(now, "", 1, 0.5, 1, 0, 1)
	assert.Nil(t, s)
	assert.Error(t, err)
}

func Test_Metric_CannotCreateSummaryWithNegativeCount(t *testing.T) {
	s, err := NewSummary(now, "summary", -1, 0.5, 1, 0, 1)
	assert.Nil(t, s)
	assert.Error(t, err)

	s, err = NewSummary(now, "summary", -1.0, 0.5, 1, 0, 1)
	assert.Nil(t, s)
	assert.Error(t, err)

	s, err = NewSummary(now, "summary", 0, 0.5, 1, 0, 1)
	assert.NotNil(t, s)
	assert.NoError(t, err)
}

func Test_Metric_AddDimension(t *testing.T) {
	attrKey := "test"
	attrVal := "value"
	g, _ := NewGauge(now, "gauge", 1)

	_ = g.AddDimension(attrKey, attrVal)
	assert.Len(t, g.GetDimensions(), 1)
}

func Test_Metric_CannotAddDimensionWithEmptyKey(t *testing.T) {
	g, _ := NewGauge(now, "gauge", 1)
	err := g.AddDimension("", "value")
	assert.Error(t, err)

	assert.Len(t, g.GetDimensions(), 0)
}

func Test_Metric_AttributeReturnsTheAttributeValue(t *testing.T) {
	attrKey := "test"
	attrVal := "value"
	g, _ := NewGauge(now, "gauge", 1)
	_ = g.AddDimension(attrKey, attrVal)

	val := g.Dimension(attrKey)
	assert.Equal(t, attrVal, val)
}

func Test_Metric_CreateCumulativeCount(t *testing.T) {
	cc, _ := NewCumulativeCount(now, "cumulative count", 1)
	assert.NotNil(t, cc)
}

func Test_Metric_CannotCreateCumulativeCountWithEmptyName(t *testing.T) {
	cc, err := NewCumulativeCount(now, "", 1)
	assert.Nil(t, cc)
	assert.Error(t, err)
}

func Test_Metric_CannotCreateCumulativeCountWithNegativeValue(t *testing.T) {
	cc, err := NewCumulativeCount(now, "count", -1)
	assert.Nil(t, cc)
	assert.Error(t, err)

	cc, err = NewCumulativeCount(now, "count", -1.0)
	assert.Nil(t, cc)
	assert.Error(t, err)

	cc, err = NewCumulativeCount(now, "count", 0)
	assert.NotNil(t, cc)
	assert.NoError(t, err)
}

func Test_Metric_CreateRate(t *testing.T) {
	r, _ := NewRate(now, "rate", 110)
	assert.NotNil(t, r)
}

func Test_Metric_CannotCreateCreateRateWithEmptyName(t *testing.T) {
	r, err := NewRate(now, "", 110)
	assert.Nil(t, r)
	assert.Error(t, err)
}

func Test_Metric_CreateCumulativeRate(t *testing.T) {
	cr, _ := NewCumulativeRate(now, "rate", 110)
	assert.NotNil(t, cr)
}

func Test_Metric_CannotCreateCumulativeRateWithEmptyName(t *testing.T) {
	cr, err := NewCumulativeRate(now, "", 110)
	assert.Nil(t, cr)
	assert.Error(t, err)
}

func Test_Metric_CanCreateSummaryWithNan(t *testing.T) {
	s, err := NewSummary(now, "summary-with-nan", 1, math.NaN(), 10, math.NaN(), math.NaN())
	assert.NotNil(t, s)
	assert.NoError(t, err)
}

func Test_Metric_CreatePrometheusHistogram(t *testing.T) {
	ph, err := NewPrometheusHistogram(now, "some-histogram", 2, 3)
	assert.NotNil(t, ph)
	assert.NoError(t, err)

	assert.Equal(t, "prometheus-histogram", ph.Type)
	assert.Equal(t, "some-histogram", ph.Name)
	assert.Equal(t, now.Unix(), ph.Timestamp)
	assert.Equal(t, uint64(2), *ph.Value.SampleCount)
	assert.Equal(t, float64(3), *ph.Value.SampleSum)
}

func Test_Metric_PrometheusHistogramAddBucket(t *testing.T) {
	ph, err := NewPrometheusHistogram(now, "some-histogram", 2, 3)
	assert.NotNil(t, ph)
	assert.NoError(t, err)

	// bucket with upper bound = 1, 1 sample
	ph.AddBucket(1, 1)
	// bucket with upper bound = 2, 2 samples (it's cumulative)
	ph.AddBucket(2, 2)

	// sampleCount should be equal to the last bucket value
	// (buckets store the number of samples for the specific upper bound so the last bucket should have the total number of samples)
	assert.Equal(t, uint64(2), *ph.Value.SampleCount)
	// sampleSum is the sum of all "observed" values
	assert.Equal(t, float64(3), *ph.Value.SampleSum)
	assert.Len(t, ph.Value.Buckets, 2)
}

func Test_Metric_CreatePrometheusSummary(t *testing.T) {
	ps, err := NewPrometheusSummary(now, "some-summary", 2, 3)
	assert.NotNil(t, ps)
	assert.NoError(t, err)

	assert.Equal(t, "prometheus-summary", ps.Type)
	assert.Equal(t, "some-summary", ps.Name)
	assert.Equal(t, now.Unix(), ps.Timestamp)
	assert.Equal(t, uint64(2), *ps.Value.SampleCount)
	assert.Equal(t, float64(3), *ps.Value.SampleSum)
}

func Test_Metric_PrometheusSummaryAddQuantile(t *testing.T) {
	ps, err := NewPrometheusSummary(now, "some-summary", 2, 3)
	assert.NotNil(t, ps)
	assert.NoError(t, err)

	// 50th quantile (median) with 1 sample with value 1
	ps.AddQuantile(0.5, 1)
	// 99th quantile with 1 sample with value 2 (it's NOT cumulative)
	ps.AddQuantile(0.9, 2)

	// sampleCount should be equal to the last bucket value
	// (buckets store the number of samples for the specific upper bound so the last bucket should have the total number of samples)
	assert.Equal(t, uint64(2), *ps.Value.SampleCount)
	// sampleSum is the sum of all "observed" values
	assert.Equal(t, float64(3), *ps.Value.SampleSum)
	assert.Len(t, ps.Value.Quantiles, 2)
}
